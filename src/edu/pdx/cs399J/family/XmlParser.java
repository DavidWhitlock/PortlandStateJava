package edu.pdx.cs410J.familyTree;

import edu.pdx.cs410J.ParserException;

import java.io.*;
import java.text.*;
import java.util.*;
import javax.xml.parsers.*;

import org.apache.xerces.parsers.*;
import org.w3c.dom.*;
import org.xml.sax.*;

/**
 * This class parses an XML file generated by <code>XmlDumper</code>
 * and creates a family tree.
 *
 * @author David Whitlock
 */
public class XmlParser implements Parser {

  private FamilyTree tree;  // The family tree we're building
  private InputStream in;  // Read XML file from here

  /**
   * Creates a new XML parser that reads its input from a file of a
   * given name.
   */
  public XmlParser(String fileName) throws FileNotFoundException {
    this(new File(fileName));
  }

  /**
   * Creates a new XML parser that reads its input from the given
   * file.
   */
  public XmlParser(File file) throws FileNotFoundException {
    this(new FileInputStream(file));
  }

  /**
   * Creates a new XML parser that reads itsinput from the given
   * <code>InputStream</code>.  This lets us read from a source other
   * than a file.
   */
  XmlParser(InputStream in) {
    this.in = in;
  }

  /**
   * Examines a chuck of a DOM tree and extracts a String from its
   * text.
   */
  private static String extractString(Node node) {
    return(node.getFirstChild().getNodeValue());
  }

  /**
   * Examines a chunk of a DOM tree and extracts an int from its
   * text.
   */
  private static int extractInteger(Node node) 
    throws ParserException {

    String text = extractString(node);
    try {
      return(Integer.parseInt(text));

    } catch(NumberFormatException ex) {
      throw new ParserException("Bad integer: " + text);
    }
  }

  /**
   * Examines a chunk of a DOM tree and extracts a <code>Date</code>
   * from it.
   */
  private static Date extractDate(Element root) 
    throws ParserException {

    // Make sure we're dealing with a data
    if(!root.getNodeName().equals("date")) {
      throw new ParserException("Not a <date>: " +
				root.getNodeName() + ", '" +
				root.getNodeValue() + "'");
    }

    Calendar cal = Calendar.getInstance();

    NodeList children = root.getChildNodes();
    for(int i = 0; i < children.getLength(); i++) {
      Node node = children.item(i);
      if(!(node instanceof Element)) {
	continue;
      }

      Element element = (Element) node;
      if(element.getNodeName().equals("month")) {
	cal.set(Calendar.MONTH, extractInteger(element));

      } else if(element.getNodeName().equals("day")) {
	cal.set(Calendar.DATE, extractInteger(element));

      } else if(element.getNodeName().equals("year")) {
	cal.set(Calendar.YEAR, extractInteger(element));

      } else {
	String s = "Invalidate element in date: " +
	  element.getNodeName();
	throw new ParserException(s);
      }
    }

    return(cal.getTime());
  }

  /**
   * Examines a chunk of a DOM tree and adds a person to the family
   * tree.
   */
  private void handlePerson(Element root) throws ParserException {
    // Make sure that we're dealing with a person here
    if(!root.getNodeName().equals("person")) {
      throw new ParserException("Expecting a <person>");
    }

    Person person = null;

    NodeList elements = root.getChildNodes();
    for(int i = 0; i < elements.getLength(); i++) {
      Node node = elements.item(i);
      if(!(node instanceof Element)) {
	continue;
      }

      Element element = (Element) node;
      if(element.getNodeName().equals("id")) {
	int id = extractInteger(element);
	person = this.tree.getPerson(id);
	continue;

      } else if(element.getNodeName().equals("firstname")) {
	person.setFirstName(extractString(element));

      } else if(element.getNodeName().equals("lastname")) {
	person.setLastName(extractString(element));

      } else if(element.getNodeName().equals("middlename")) {
	person.setMiddleName(extractString(element));

      } else if(element.getNodeName().equals("dob")) {
	Element dob = null;

	NodeList list = element.getChildNodes();
	for(int j = 0; j < list.getLength(); j++) {
	  Node n = list.item(j);
	  if(n instanceof Element) {
	    dob = (Element) n;
	    break;
	  }
	}
	
	if(dob == null) {
	  throw new ParserException("No <date> in <dob>?");
	}

	person.setDateOfBirth(extractDate(dob));

      } else if(element.getNodeName().equals("dod")) {
        Element dod = null;

        NodeList list = element.getChildNodes();
        for(int j = 0; j < list.getLength(); j++) {
          Node n = list.item(j);
          if(n instanceof Element) {
            dod = (Element) n;
            break;
          }
        }

        if(dod == null) {
          throw new ParserException("No <date> in <dod>?");
        }

	person.setDateOfDeath(extractDate(dod));

      } else if(element.getNodeName().equals("father-id")) {
	String s = extractString(element);
	int id = 0;
	try {
	  id = Integer.parseInt(s);

	} catch(NumberFormatException ex) {
	  throw new ParserException("Bad father-id: " + s);
	}

	person.setFather(this.tree.getPerson(id));

      } else if(element.getNodeName().equals("mother-id")) {
        String s = extractString(element);
        int id = 0;
        try {
          id = Integer.parseInt(s);

        } catch(NumberFormatException ex) {
          throw new ParserException("Bad mother-id: " + s);
        }

        person.setMother(this.tree.getPerson(id));
      }
    }
  }

  /**
   * Examines a chunk of a DOM tree and makes note of a marriage. 
   */
  private void handleMarriage(Element root) throws ParserException {
    // Make sure we're dealing with a marriage
    if(!root.getNodeName().equals("marriage")) {
      throw new ParserException("");
    }

    int husband_id = 0;
    int wife_id = 0;

    // Extract the husband and wife id's
    NamedNodeMap attrs = root.getAttributes();
    for(int i = 0; i < attrs.getLength(); i++) {
      Node attr = attrs.item(i);
      if(attr.getNodeName().equals("husband-id")) {
	String id = attr.getNodeValue();

	try {
	  husband_id = Integer.parseInt(id);

	} catch(NumberFormatException ex) {
	  throw new ParserException("Bad husband id: " + id);
	}

      } else if(attr.getNodeName().equals("wife-id")) {
	String id = attr.getNodeValue();

	try {
	  wife_id = Integer.parseInt(id);
	} catch(NumberFormatException ex) {
	  throw new ParserException("Bad wife id: " + id);
	}
      }
    }

    // Make a Marriage
    Person husband = this.tree.getPerson(husband_id);
    Person wife = this.tree.getPerson(wife_id);

    Marriage marriage = new Marriage(husband, wife);
    husband.addMarriage(marriage);
    wife.addMarriage(marriage);

    // Fill in info about the marriage
    NodeList elements = root.getChildNodes();
    for(int i = 0; i < elements.getLength(); i++) {
      Node node = elements.item(i);
      if(!(node instanceof Element)) {
	continue;
      }

      Element element = (Element) node;
      if(element.getNodeName().equals("location")) {
	marriage.setLocation(extractString(element));

      } else if(element.getNodeName().equals("date")) {
	marriage.setDate(extractDate(element));
      }
    }
  }

  /**
   * Parses the specified input source in XML format and from it
   * creates a family tree.
   */
  public FamilyTree parse() throws ParserException {
    this.tree = new FamilyTree();

    // Create a DOM tree from the XML source
    DOMParser parser = new DOMParser();
    try {
      String f = "http://apache.org/xml/features/dom/defer-node-expansion";
      parser.setFeature(f, false);
      parser.setFeature("http://xml.org/sax/features/validation", true);

      // Since we traverse all the nodes, its more efficient to not
      // use deferred nodes, but the exceptions are ignorable if
      // there's a glitch.

    } catch (SAXNotRecognizedException snr) {
    } catch (SAXNotSupportedException sns) {
    }

    try {
      parser.parse(new InputSource(in));

    } catch(SAXException ex) {
      throw new ParserException("While parsing XML source: " + ex);

    } catch(IOException ex) {
      throw new ParserException("While parsing XML source: " + ex);
    }

    Document doc = parser.getDocument();

    Element root = (Element) doc.getChildNodes().item(1);

    // Make sure that we are really dealing with a family tree
    if(!root.getNodeName().equals("familytree")) {
      throw new ParserException("Not a family tree XML source: " +
                                root.getNodeName());
    }

    NodeList stuff = root.getChildNodes();
    for(int i = 0; i < stuff.getLength(); i++) {
      Node node = stuff.item(i);

      if(!(node instanceof Element)) {
	// Ignore whitespace text and other stuff
	continue;
      }

      Element element = (Element) node;

      if(element.getNodeName().equals("person")) {
	handlePerson(element);

      } else if(element.getNodeName().equals("marriage")) {
	handleMarriage(element);

      } else {
	String s = "A family tree should not have a " +
	  element.getNodeName();
	throw new ParserException(s);
      }
    }

    return(this.tree);
  }

  /**
   * Test program.  Parses an XML file specified on the command line
   * and prints the resulting family tree to standard out.
   */
  public static void main(String[] args) {
    if(args.length == 0) {
      System.err.println("** Missing file name");
      System.exit(1);
    }

    // Parse the input file
    String fileName = args[0];
    try {
      Parser parser = new XmlParser(fileName);
      FamilyTree tree = parser.parse();

      PrintWriter out = new PrintWriter(System.out, true);
      PrettyPrinter pretty = new PrettyPrinter(out);
      pretty.dump(tree);

    } catch(FileNotFoundException ex) {
      System.err.println("** Could not find file " + fileName);

    } catch(ParserException ex) {
      System.err.println("** " + ex.getMessage());
    }
  }
  
}
